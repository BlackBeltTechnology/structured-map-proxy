# structured-map-proxy

## What is this library about?

It combines interface based proxys with java.util.Map backends. This means that you can define typesafe handlers to dynamic strcutures as Map and Collection of maps over the Map and Collection defined generics.

It can handle nested interfaces too, so all types of structures can be defined with a structure of interfaces.

The map entries and interface methods are mapped as per the JavaBean standard specification. This results in for example: a String named as `stringValue` in a Map to have a corresponding interface containing `getStringValue` and `setStringValue`.

## Usage

Add the following to your pom.xml:

[source,xml]
----
<dependency>
  <groupId>hu.blackbelt</groupId>
  <artifactId>structured-map-proxy</artifactId>
  <version>LATEST</version>
  <type>bundle</type>
</dependency>
----

## Example:

In this example we have a `User` which can have a `UserDetail` as a single and containment collection.


### Define getters/and setters in interfaces

[source,java]
----
public interface Entity extends Serializable {
    Serializable getId();
    void setId(Serializable id);
}

public interface User extends Entity {
    Boolean getActive();
    void setActive(Boolean active);

    String getCredential();
    void setCredential(String credential);

    String getEmail();
    void setEmail(String email);

    Optional<String> getFirstName();
    void setFirstName(String firstName);

    Optional<String> getLastName();
    void setLastName(String lastName);

    Optional<String> getLoginName();
    void setLoginName(String loginName);

    LocalDateTime getLastLoginTime();
    void setLastLoginTime(LocalDateTime lastLoginTime);
 
    UserDetail getSingleUserDetail();
    void setSingleUserDetail(UserDetail userDetail);

    Collection<UserDetail> getUserDetails();
    void setUserDetails(Collection<UserDetail> userDetails);
}

public interface UserDetail {
    String getId();
    void setId(String id);

    String getNote();
    void setNote(String note);
}
----


### Create a Proxy from a Map

[source,java]
----
// Create map represents fields.
Map<String, Object> prepared = new HashMap<>();
prepared.put("active", true);
prepared.put("id", "1");
prepared.put("email", Optional.of("test@test.com"));
prepared.put("loginName", Optional.of("teszt"));
prepared.put("lastLoginTime", Optional.of(time));
prepared.put("userDetails", ImmutableList.of(ImmutableMap.of("id", "1", "note", "Note1")));

User user = MapProxy.builder(User.class)
        .withMap(prepared)
        .newInstance();

user.setEmail("another@example.com");
----


### Create a Map from a Proxy

[source,java]
----
// Create an empty proxy
User user = MapProxy.builder(User.class).newInstance();
user.setActive(true);
user.setLoginName("teszt");
user.setId("1");

UserDetail userDetail1 = MapProxy.builder(UserDetail.class).newInstance();
userDetail1.setId("1");
userDetail1.setNote("Note1");

UserDetail userDetail2 = MapProxy.builder(UserDetail.class).newInstance();
userDetail2.setId("2");
userDetail2.setNote("Note2");

user.setUserDetails(ImmutableList.of(userDetail1, userDetail2));

Map<String, Object> mapRepresentation = ((MapHolder) user).toMap();
----

> Not only Bean-type proxies are supported. Interfaces for builders can also be defined


### Define builder interfaces

[source,java]
----
public interface UserBuilder {
    UserBuilder id(Serializable id);
    UserBuilder active(Boolean par);
    UserBuilder credential(String par);
    UserBuilder email(String par);
    UserBuilder firstName(String par);
    UserBuilder lastName(String par);
    UserBuilder loginName(String par);
    UserBuilder lastLoginTime(LocalDateTime par);
    UserBuilder userDetails(Collection<UserDetail> userDetails);
    UserBuilder singleUserDetail(UserDetail userDetail);

    User build();
}
----


### Create a Proxy builder for a type

[source,java]
----
User user = MapBuilderProxy.builder(UserBuilder.class, User.class).newInstance()
     .id("1")
     .active(true)
     .loginName("teszt")
     .build();
----


## Supported options in MapProxy

### Immutable option example

[source,java]
----
MapProxy.builder(User.class).withImmutable(true).newInstance();
----

MapProxy supports the following options:

- immutable (default `false`)
Adjusts the fields and collections in the created proxy as immutable, which results in all mutating operation calls triggering an `IllegalStateException`
- nullSafeCollection (default `false`)
If set to `true` and given a collection is not set in the map, an empty collection will be returned. Which means that the collection in the interface can never be null.
- identifierField (default `none`)
Special field which can be used to determinate equality of 2 instances. When it is not defined the String representation of the 2 objects is used for `equals`
- enumMappingMethod (default `name`)
When an enum type is defined as a field, we need to define what type of representation is coded in the map.

## Supported options in MapBuilderProxy

The MapBuilderProxy's builder supports additional options. For example:

### Adding a Builder method prefix
[source,java]
----
User user = MapBuilderProxy.builder(UserBuilder.class, User.class).withBuilderMethodPrefix("with").newInstance()
     .id("1")
     .active(true)
     .loginName("teszt")
     .build();
----


- builderMethodPrefix (default `false`)
It defines whether the buidler method can have a prefix or not. By default the builder method names match with the field name. With this option you can rename them.
- enumMappingMethod (default `name`)
When an enum type is defined as a field, we need to define what type of representation is coded in the map.
